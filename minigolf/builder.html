<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Level Builder</title>
    <style>
        /* Basic styles */
        #left-panel,
        #canvas,
        #properties {
            float: left;
            margin: 10px;
        }

        #canvas {
            position: relative;
            width: 600px;
            height: 400px;
            border: 1px solid #ccc;
            background-image: linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            /* Grid size */
        }

        .draggable {
            padding: 5px;
            margin: 5px;
            background-color: #f0f0f0;
            cursor: move;
            user-select: none;
            /* Prevent text selection */
        }

        .selected {
            outline: 2px dashed blue;
            /* Highlight selected object */
        }

        #shape-inputs {
            display: none;
            /* Initially hidden */
        }

        #returnButton {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #returnButton:hover {
            background-color: #0056b3;
        }
    </style>
</head>

<body>
    <button id="returnButton">üè† Return to game</button>
    <div id="left-panel">
        <h3>Available Objects</h3>
        <div draggable="true" id="ball" class="draggable">‚öΩ</div>
        <div draggable="true" id="hole" class="draggable">üï≥Ô∏è</div>
        <div draggable="true" id="sandtrap" class="draggable">üèñÔ∏è</div>
        <div draggable="true" id="tubes" class="draggable">üåÄ</div>
        <div draggable="true" id="windmill" class="draggable">üå™Ô∏è</div>
        <button id="draw-area-btn">Draw Area</button>
        <div id="shape-inputs">
            <h4>Define Shape</h4>
            <select id="shape-operation">
                <option value="ADD">Add</option>
                <option value="SUB">Subtract</option>
            </select>
            <input type="text" id="shape-type" placeholder="rect/oval">
            <input type="number" id="shape-x" placeholder="X">
            <input type="number" id="shape-y" placeholder="Y">
            <input type="number" id="shape-width" placeholder="Width">
            <input type="number" id="shape-height" placeholder="Height">
            <button id="add-shape-btn">Add Shape</button>
        </div>
    </div>
    <div id="canvas"></div>
    <div id="properties">
        <h3>Properties</h3>
        <div>
            <label for="par-input">Par:</label>
            <input type="number" id="par-input" min="1" value="2">
        </div>
        <div id="property-info"></div>
        <button id="export-btn">Export Level</button>
    </div>

    <script>
        document.getElementById('returnButton').addEventListener('click', () => {
            const currentPath = window.location.pathname;
            const newPath = currentPath.substring(0, currentPath.lastIndexOf('/')) + '/index.html';
            window.location.href = newPath;
        });

        const canvas = document.getElementById('canvas');
        const exportBtn = document.getElementById('export-btn');
        const parInput = document.getElementById('par-input');
        const drawAreaBtn = document.getElementById('draw-area-btn');
        const shapeInputs = document.getElementById('shape-inputs');
        const shapeOperationInput = document.getElementById('shape-operation');
        const shapeTypeInput = document.getElementById('shape-type');
        const shapeXInput = document.getElementById('shape-x');
        const shapeYInput = document.getElementById('shape-y');
        const shapeWidthInput = document.getElementById('shape-width');
        const shapeHeightInput = document.getElementById('shape-height');
        const addShapeBtn = document.getElementById('add-shape-btn');
        let selectedObject = null; // To track the selected object

        // Ensure par input is positive
        parInput.addEventListener('input', () => {
            const value = parseInt(parInput.value, 10);
            if (value < 1) {
                parInput.value = Math.abs(value);
            }
        });

        drawAreaBtn.addEventListener('click', () => {
            shapeInputs.style.display = shapeInputs.style.display === 'none' ? 'block' : 'none';
        });

        addShapeBtn.addEventListener('click', () => {
            const operation = shapeOperationInput.value;
            const type = shapeTypeInput.value.toLowerCase();
            const x = parseInt(shapeXInput.value, 10);
            const y = parseInt(shapeYInput.value, 10);
            const width = parseInt(shapeWidthInput.value, 10);
            const height = parseInt(shapeHeightInput.value, 10);

            let shape;
            if (type === 'rect') {
                shape = document.createElement('div');
                shape.style.position = 'absolute';
                shape.style.left = `${x}px`;
                shape.style.top = `${y}px`;
                shape.style.width = `${width}px`;
                shape.style.height = `${height}px`;
                shape.style.backgroundColor = operation === 'ADD' ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
            } else if (type === 'oval') {
                shape = document.createElement('div');
                shape.style.position = 'absolute';
                shape.style.left = `${x - width / 2}px`; // Center oval
                shape.style.top = `${y - height / 2}px`;
                shape.style.width = `${width}px`;
                shape.style.height = `${height}px`;
                shape.style.borderRadius = '50%';
                shape.style.backgroundColor = operation === 'ADD' ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
            }

            if (shape) {
                shape.setAttribute('data-operation', operation); // Store operation type
                shape.setAttribute('data-type', type); // Store shape type
                canvas.appendChild(shape);
                makeDraggable(shape);
                shapeTypeInput.value = '';
                shapeXInput.value = '';
                shapeYInput.value = '';
                shapeWidthInput.value = '';
                shapeHeightInput.value = '';
            }
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            const objectId = e.dataTransfer.getData('text/plain');
            const element = document.getElementById(objectId);

            // Check if the dropped object is a ball
            if (objectId === 'ball') {
                const existingBall = document.getElementById('ball-instance');
                if (existingBall) {
                    canvas.removeChild(existingBall);
                }
            }

            const newObject = element.cloneNode(true);
            newObject.id = `${objectId}-instance`; // Give it a unique ID
            newObject.style.position = 'absolute';

            // Snap to grid
            let x = Math.floor(e.offsetX / 20) * 20;
            let y = Math.floor(e.offsetY / 20) * 20;

            newObject.style.left = `${x}px`;
            newObject.style.top = `${y}px`;
            canvas.appendChild(newObject);

            // Add drag functionality for the new object
            makeDraggable(newObject);
        });

        // Function to make an object draggable
        function makeDraggable(element) {
            let offsetX, offsetY;

            element.addEventListener('mousedown', (e) => {
                // Select the object
                selectObject(element);

                offsetX = e.clientX - element.getBoundingClientRect().left;
                offsetY = e.clientY - element.getBoundingClientRect().top;

                function mouseMoveHandler(e) {
                    const x = Math.floor((e.clientX - canvas.getBoundingClientRect().left - offsetX) / 20) * 20;
                    const y = Math.floor((e.clientY - canvas.getBoundingClientRect().top - offsetY) / 20) * 20;
                    element.style.left = `${x}px`;
                    element.style.top = `${y}px`;
                }

                function mouseUpHandler() {
                    document.removeEventListener('mousemove', mouseMoveHandler);
                    document.removeEventListener('mouseup', mouseUpHandler);
                }

                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
            });

            element.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering on canvas click
                selectObject(element);
            });
        }

        // Function to select an object
        function selectObject(element) {
            if (selectedObject) {
                selectedObject.classList.remove('selected'); // Remove selection from previous object
            }
            selectedObject = element;
            selectedObject.classList.add('selected'); // Highlight selected object
        }

        // Handle keydown event for deleting the selected object
        document.addEventListener('keydown', (e) => {
            if (selectedObject && (e.key === 'Delete' || e.key === 'Backspace')) {
                canvas.removeChild(selectedObject);
                selectedObject = null; // Clear selection
            }
        });

        // Event listeners for dragging objects in the left panel
        document.querySelectorAll('.draggable').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.id);
            });
        });

        exportBtn.addEventListener('click', () => {
            const levels = [];
            const level = {
                ballPosition: [],
                holePosition: [],
                area: '',
                obstacles: [],
                par: Math.abs(parseInt(parInput.value, 10)), // Get the par value
            };

            const objects = Array.from(canvas.children);
            objects.forEach(obj => {
                const rect = obj.getBoundingClientRect();
                const x = Math.round(rect.left - canvas.getBoundingClientRect().left);
                const y = Math.round(rect.top - canvas.getBoundingClientRect().top);

                if (obj.id.includes('ball-instance')) {
                    level.ballPosition = [x, y];
                } else if (obj.id.includes('hole')) {
                    level.holePosition = [x, y];
                } else {
                    let obstacleData = { type: obj.id.replace('-instance', ''), position: [x, y] };

                    if (obj.id === 'sandtrap') {
                        obstacleData.width = 100; // Example width
                        obstacleData.height = 30; // Example height
                    } else if (obj.id === 'tubes') {
                        obstacleData.targetPosition = [x + 25, y + 25]; // Example target position
                    }

                    level.obstacles.push(obstacleData);
                }
            });

            level.area = constructAreaDefinition(objects);

            // Prepare the obstacles for export
            let obstacleExport = level.obstacles.map(obstacle => {
                switch (obstacle.type) {
                    case 'sandtrap':
                        return `ADD Sandtrap ${obstacle.position[0]} ${obstacle.position[1]} ${obstacle.width} ${obstacle.height};`;
                    case 'tubes':
                        return `ADD Tubes ${obstacle.position[0]} ${obstacle.position[1]} ${obstacle.targetPosition[0]} ${obstacle.targetPosition[1]};`;
                    case 'windmill':
                        return `ADD Windmill ${obstacle.position[0]} ${obstacle.position[1]};`;
                    default:
                        console.warn(`Unknown object type: ${obstacle.type}`);
                        return '';
                }
            }).join('\n');

            level.obstacles = obstacleExport;

            levels.push(level);
            const levelData = JSON.stringify(levels, null, 2);

            // Save to local storage
            localStorage.setItem('levels', levelData);
            console.log('Level saved to local storage:', levelData);

            // Create a blob and download it as a file
            const blob = new Blob([levelData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'level.json';
            a.click();
            URL.revokeObjectURL(url);
            console.log('Level downloaded as level.json');
        });

        function constructAreaDefinition(objects) {
            let areaDefinition = '';
            objects.forEach(obj => {
                if (!obj.id.includes('instance') && obj.hasAttribute('data-operation')) {
                    const operation = obj.getAttribute('data-operation');
                    const type = obj.getAttribute('data-type');
                    const rect = obj.getBoundingClientRect();
                    const x = Math.round(rect.left - canvas.getBoundingClientRect().left);
                    const y = Math.round(rect.top - canvas.getBoundingClientRect().top);
                    const width = Math.round(rect.width);
                    const height = Math.round(rect.height);
                    areaDefinition += `${operation} ${type} ${x}, ${y}, ${width}, ${height};\n`;
                }
            });
            return areaDefinition;
        }
    </script>
</body>

</html>